var http = require('http');
var fs = require('fs');
var url = require('url');
//var axios = require('axios');
var XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest;
var siter = fs.readFileSync(__dirname + '/coder testing1.html');
var theChat = []; var theList = [];
var aoi = 0;
var myLocalIp = ""; var myIP = "";
var ifTrue = true;
var theName = ""; var theKey = ""; var theCode = "";
var toAll = {};
var msl = fs.readFileSync(__dirname + '/mainserverlocation.txt').toString();
console.log("open a browser tab and go to 'localhost:8082' to connect");
var myAddr = ""; var pKeyy = ""; var pKey = ""; var pKeyTEXT = JSON.parse(fs.readFileSync(__dirname + '/JSON/(' + pKey + ').json').toString());

var oi = "yes"; isLogged = false; var pii = []; var pKet = ""//someSecretKey.. will make this an agreed thing from user to server but for now it's secret

const ngrok = require('ngrok');
(async function() {
  myAddr = await ngrok.connect(8082);
})();














///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function commEncrypt (key, data, pKey1) {/*lol won't share this yet.. just*/}

//++++++++++++

function commDecrypt (key, data, pKey1) {/*the server management is below.. the parts you can help me out with*/}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////














function randomise (theLetter, theNumber, theList) {
let lenp = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "~", "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", ">", "<", "-", "_", "+", "=", "{", ":", "\\", "[", "]", "|", ".", "?", "/", "}", ";", " "];
if (theLetter != undefined) {lenp.forEach((a,i)=>{if(a===theLetter){lenp.splice(i,1);}});}
    var aToi = Math.random() * 10; aToi += 10; aToi = Math.floor(aToi);
    if (theNumber != undefined) {aToi = theNumber;}
    if (theList != undefined) {lenp = theList;}
    var toReturn = "";
    for (var i = 0; i < aToi; i++) {
        var bToi = Math.random() * lenp.length; bToi = Math.floor(bToi);
        toReturn += lenp[bToi];
    }
    return(toReturn);
}
function search (theItem, theList) {
    var ifTrue = false;
    for (var i = 0; i < theList.length; i++) {
      if (theList[i] === theItem) {ifTrue = true;}
    }
    return(ifTrue);
}

function _logout (res) {
  var xhd = new XMLHttpRequest(); xhd.open('POST', msl, true); xhd.setRequestHeader("s", commEncrypt(pKet, "logout")); xhd.setRequestHeader("n", commEncrypt(pKet, theName)); xhd.setRequestHeader("p", commEncrypt(pKet, theKey)); xhd.send();
  xhd.onload = function () {isLogged = false; res.write(xhd.responseText); clearInterval(toAll.toInterval); /*clearTimeout(toAll.toTimeout);*/ res.end();} //even if incorrect data is entered here, because of afk rules on the mainserver, you would still logout
}
function startInterval () {toAll.toInterval = setInterval(()=>{var xhd = new XMLHttpRequest(); xhd.open('POST', msl, true); xhd.setRequestHeader("s", commEncrypt(pKet, "killT")); xhd.setRequestHeader("p", commEncrypt(pKet, theKey)); xhd.setRequestHeader("n", commEncrypt(pKet, theName)); xhd.send();}, 3000);}
//function startTimeout () {toAll.toTimeout = setTimeout(()=>{var xhd = new XMLHttpRequest(); xhd.open('POST', msl, true); xhd.setRequestHeader("s", commEncrypt(pKet, "logout")); xhd.setRequestHeader("p", commEncrypt(pKet, theKey)); xhd.setRequestHeader("n", commEncrypt(pKet, theName)); xhd.send(); clearInterval(toAll.toInterval); oi="no"}, 5000);} ///logout if localhost stops asking for text(action stopped since it creates useless flaws)

function randomWarning () {
let lenp = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "~", "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", ">", "<", "-", "_", "+", "=", "{", ":", "\\", "[", "]", "|", ",", ".", "?", "/", "}", ";", " "];
    var aToi = Math.random() * 10; aToi += 10; aToi = Math.floor(aToi);
    var toReturn = "";
    for (var i = 0; i < aToi; i++) {
        var bToi = Math.random() * lenp.length; bToi = Math.floor(bToi);
        toReturn += lenp[bToi];
    }
    toReturn += "_almostNoMessageIsTheSame";
    return(toReturn);
}

/*
axios.get('https://ipinfo.io/json').then(response => {
  myIP = response.data.ip;
  require('dns').lookup(require('os').hostname(), function (err, add, fam) {
    myLocalIp = add; //run function now
  });
}).catch(error => {console.log(error);});


var xhr = new XMLHttpRequest();
xhr.open('GET', "https://ipinfo.io/json", true);
xhr.send();
xhr.onload = function(){console.log(JSON.parse(xhr.responseText)["ip"]);}
*/






var x = http.createServer(function (req, res) {
  if (req.method === "GET") {
    delete(toAll.closed); res.write(siter); res.end();
  }
  else if (req.method === "POST") {
    if (req.headers.s === "neither" && req.headers.host === "localhost:8082") {
      if (req.headers.m != "" && req.headers.m != undefined) {
        theList.forEach((a,i)=>{
          var xhd = new XMLHttpRequest();
          xhd.open('POST', a, true);
          xhd.setRequestHeader("s", commEncrypt(pKet, "aMessage"));
          xhd.setRequestHeader("pi", commEncrypt(pKet, theName));
          xhd.send(commEncrypt(theCode, '<b id="'+randomWarning()+'">'+theName+': </b>'+req.headers.m, pKeyy));
        });
      }
      res.end();
    }
    else if (req.headers.s === "either" && req.headers.host === "localhost:8082") {
      //aoi = req.headers.num * 1;
      res.setHeader("oi", oi); var instaText = [];
      for (var i = 0; i < theChat.length; i++) {
        instaText[i]={}
        if (pii[i] === theName) {instaText[i].you=true}
        else {instaText[i].you=false}
        instaText[i].text=commDecrypt(theCode, theChat[i], pKeyy)
      }
      res.write(JSON.stringify(instaText)); theChat = []; pii = []
      //clearTimeout(toAll.toTimeout); startTimeout(); ///logout if localhost stops asking for text(action stopped since it creates useless flaws)
      pKey = ""; res.end();
    }
    else if (req.headers.s === "no" && req.headers.n != undefined && req.headers.p != undefined && req.headers.host === "localhost:8082") {
      if (isLogged === false) {//FIND IP
        var xhd = new XMLHttpRequest(); //console.log(myAddr);
        xhd.open('POST', msl, true);
        xhd.setRequestHeader("s", commEncrypt(pKet, req.headers.s));
        xhd.setRequestHeader("p", commEncrypt(pKet, req.headers.p));
        xhd.setRequestHeader("n", commEncrypt(pKet, req.headers.n));
        xhd.setRequestHeader("ip", commEncrypt(pKet, myAddr));
        xhd.send();
        xhd.onload = function() {if (xhd.responseText === req.headers.n) {isLogged = true; theName = req.headers.n; theKey = req.headers.p; /*startTimeout();*/ startInterval();} res.write(xhd.responseText); res.end();}
      }//FIND IP
      else{res.end("Your Device's host is already logged in to an account. CANNOT Login TWICE");} //verification of simultaneous login on one device also verified by main-server BTW :)
    }
    else if (req.headers.s === "yes" && req.headers.n != undefined && req.headers.p != undefined && req.headers.host === "localhost:8082") {
      var xhd = new XMLHttpRequest();
      xhd.open('POST', msl, true);
      xhd.setRequestHeader("s", commEncrypt(pKet, req.headers.s));
      xhd.setRequestHeader("p", commEncrypt(pKet, req.headers.p));
      xhd.setRequestHeader("n", commEncrypt(pKet, req.headers.n));
      xhd.send();
      xhd.onload = function() {res.write(xhd.responseText); res.end();}
    }
    else if (req.headers.s === "logout" && req.headers.host === "localhost:8082") {
      _logout(res)
    }
    else if (req.headers.s === "createRoom" && req.headers.n != undefined && req.headers.p != undefined && req.headers.z != undefined && req.headers.host === "localhost:8082") { var zz = req.headers.z;
      var xhd = new XMLHttpRequest();
      xhd.open('POST', msl, true);
      xhd.setRequestHeader("s", commEncrypt(pKet, "createRoom"));
      xhd.setRequestHeader("n", commEncrypt(pKet, theName));
      xhd.setRequestHeader("p", commEncrypt(pKet, theKey));
      xhd.setRequestHeader("m", commEncrypt(pKet, req.headers.n));
      xhd.setRequestHeader("q", commEncrypt(pKet, req.headers.p));
      if(zz!="yes"){zz="no"} xhd.setRequestHeader("z", commEncrypt(pKet, zz));
      xhd.send();
      xhd.onload = function () {res.write(xhd.responseText); res.end();}
    }
    else if (req.headers.s === "joinRoom" && req.headers.n != undefined && req.headers.p != undefined && req.headers.z != undefined && req.headers.host === "localhost:8082") { var zz = req.headers.z; //console.log(zz);
      var xhd = new XMLHttpRequest();
      xhd.open('POST', msl, true);
      xhd.setRequestHeader("s", commEncrypt(pKet, "joinRoom"));
      xhd.setRequestHeader("n", commEncrypt(pKet, theName));
      xhd.setRequestHeader("p", commEncrypt(pKet, theKey));
      xhd.setRequestHeader("m", commEncrypt(pKet, req.headers.n));
      xhd.setRequestHeader("q", commEncrypt(pKet, req.headers.p));
      if(zz!="yes"){zz="no"} xhd.setRequestHeader("z", commEncrypt(pKet, zz));
      xhd.send();
      xhd.onload = function () {if (xhd.responseText === "Success") {if (zz === "yes") {pKeyy = req.headers.n;} else {pKeyy = "";} theCode = req.headers.p;} res.write(xhd.responseText); res.end();}
    }
    else if (commDecrypt(pKet, req.headers.s) === "ipList") { var datum = "";
      req.on('data', chunk => {
        datum += chunk;
      }); req.on('end', () => {datum = commDecrypt(pKet, datum); theList = datum.split(","); res.end();});
    }
    else if (commDecrypt(pKet, req.headers.s) === "aMessage" && req.headers.pi != undefined && commDecrypt(pKet, req.headers.pi) != "") { var datum = "";
      req.on('data', chunk => {
        datum += chunk;
      }); req.on('end', () => {theChat.push(datum); pii.push(commDecrypt(pKet, req.headers.pi)); res.end();});
    }
    else if (req.headers.s === "makeJSON" && req.headers.host === "localhost:8082") {
      var lenp = ["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","~","`","!","@","#","$","%","^","&","*","(",")",">","<","-","_","+","=","{",":","\\","[","]","|",",",".","?","/","'","\"","}",";"," "];
      var leno = []; var lepo = []; var leo = Math.random() * 7; leo = Math.ceil(leo); leo += 5; var leoo = ["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","~","!","@","#","$","%","^","&","*","(",")",">","<","-","_","+","=","{","[","]","|","}"];
      for (var i = 0; i < lenp.length; i++) {var abc = randomise("", leo, leoo); while(search(abc,leno)===true){abc=randomise("", leo, leoo);} lepo.push(abc);}
      var Aletter = randomise(",", leo, leoo);   while(search(Aletter,lepo) === true){Aletter = randomise(",", leo, leoo);}   var theCount = []; theCount.push(Aletter);
      var o34 = randomise("", leo, leoo);   while(search(o34,lepo) === true){o34 = randomise("", leo, leoo);}   while(search(o34,theCount) === true){o34 = randomise("", leo, leoo);} theCount.push(o34);
      var o35 = randomise("", leo, leoo);   while(search(o35,lepo) === true){o35 = randomise("", leo, leoo);}   while(search(o35,theCount) === true){o35 = randomise("", leo, leoo);} theCount.push(o35);
      var o36 = randomise("", leo, leoo);   while(search(o36,lepo) === true){o36 = randomise("", leo, leoo);}   while(search(o36,theCount) === true){o36 = randomise("", leo, leoo);}
      while (lenp.length != 0) {var cvb=Math.random()*lenp.length; cvb=Math.floor(cvb); leno.push(lenp[cvb]); lenp.splice(cvb,1);}
      var obj = {}; obj.leno = leno; obj.lepo = lepo; obj.Aletter = Aletter; obj.o34 = o34; obj.o35 = o35; obj.o36 = o36;   var mm = req.headers.m; if (req.headers.m === undefined || req.headers.m === "") {mm = "not named_"+randomise();} fs.writeFile(__dirname + '/JSON/('+mm+').json', JSON.stringify(obj), (err) => {if (err) throw err;});
       res.write("Successfully Created Config File"); res.end();
    }
    else if(req.headers.off=="yes"&&req.headers.host === "localhost:8082"){_logout(res);toAll.closed=true;setTimeout(()=>{if(!toAll.closed){return;}console.log('browser session ended');process.exit(0);},500)} //program ends when browser connection is closed(and now action stops if it's just a reload), so that you don't accidentally leave this open
    else if (req.headers.host === myAddr) { res.write("For Security Reasons, you must access your local slate app at 'localhost:8082'"); res.end(); }
    else {
      res.write("Invalid Request Parameters. Who ARE you?"); res.end();
    }
  }
  else {
    res.write("Invalid Request Method. Who ARE you?"); res.end();
  }
  //res.end();
  //end the response
}).listen(8082); //the server object listens on port 8082
