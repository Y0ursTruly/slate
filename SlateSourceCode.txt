var http = require('http');
var fs = require('fs');
var url = require('url');
//var axios = require('axios');
//var XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest;
var siter = fs.readFileSync(__dirname + '/coder testing1.html');
var theChat = []; var theList = [];
var aoi = 0;
var myLocalIp = ""; var myIP = "";
var ifTrue = true;
var theName = ""; var theKey = ""; var theCode = "";
var toTimeout; var toInterval;
var msl = fs.readFileSync(__dirname + '/mainserverlocation.txt').toString();
console.log("open a browser tab and go to 'localhost:8082' to connect");
var myAddr = ""; var pKeyy = ""; var pKey = ""; var pKeyTEXT = JSON.parse(fs.readFileSync(__dirname + '/JSON/(' + pKey + ').json').toString());
//xmlhttprequest localised
var Url = require("url");
var spawn = require("child_process").spawn;
//xmlhttprequest localised
var oi = "yes"; var pKet = "I cannot disclose for obvious data security reasons of this application";

const ngrok = require('ngrok');
(async function() {
  myAddr = await ngrok.connect(8082);
})();




//xmlhttprequest module begin
var XMLHttpRequest = function() {
  "use strict";

  /**
   * Private variables
   */
  var self = this;
  var http = require("http");
  var https = require("https");

  // Holds http.js objects
  var request;
  var response;

  // Request settings
  var settings = {};

  // Disable header blacklist.
  // Not part of XHR specs.
  var disableHeaderCheck = false;

  // Set some default headers
  var defaultHeaders = {
    "User-Agent": "node-XMLHttpRequest",
    "Accept": "*/*",
  };

  var headers = {};
  var headersCase = {};

  // These headers are not user setable.
  // The following are allowed but banned in the spec:
  // * user-agent
  var forbiddenRequestHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "content-transfer-encoding",
    "cookie",
    "cookie2",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "via"
  ];

  // These request methods are not allowed
  var forbiddenRequestMethods = [
    "TRACE",
    "TRACK",
    "CONNECT"
  ];

  // Send flag
  var sendFlag = false;
  // Error flag, used when errors occur or abort is called
  var errorFlag = false;

  // Event listeners
  var listeners = {};

  /**
   * Constants
   */

  this.UNSENT = 0;
  this.OPENED = 1;
  this.HEADERS_RECEIVED = 2;
  this.LOADING = 3;
  this.DONE = 4;

  /**
   * Public vars
   */

  // Current state
  this.readyState = this.UNSENT;

  // default ready state change handler in case one is not set or is set late
  this.onreadystatechange = null;

  // Result & response
  this.responseText = "";
  this.responseXML = "";
  this.status = null;
  this.statusText = null;
  
  // Whether cross-site Access-Control requests should be made using
  // credentials such as cookies or authorization headers
  this.withCredentials = false;

  /**
   * Private methods
   */

  /**
   * Check if the specified header is allowed.
   *
   * @param string header Header to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpHeader = function(header) {
    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);
  };

  /**
   * Check if the specified method is allowed.
   *
   * @param string method Request method to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpMethod = function(method) {
    return (method && forbiddenRequestMethods.indexOf(method) === -1);
  };

  /**
   * Public methods
   */

  /**
   * Open the connection. Currently supports local server requests.
   *
   * @param string method Connection method (eg GET, POST)
   * @param string url URL for the connection.
   * @param boolean async Asynchronous connection. Default is true.
   * @param string user Username for basic authentication (optional)
   * @param string password Password for basic authentication (optional)
   */
  this.open = function(method, url, async, user, password) {
    this.abort();
    errorFlag = false;

    // Check for valid request method
    if (!isAllowedHttpMethod(method)) {
      throw new Error("SecurityError: Request method not allowed");
    }

    settings = {
      "method": method,
      "url": url.toString(),
      "async": (typeof async !== "boolean" ? true : async),
      "user": user || null,
      "password": password || null
    };

    setState(this.OPENED);
  };

  /**
   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.
   * This does not conform to the W3C spec.
   *
   * @param boolean state Enable or disable header checking.
   */
  this.setDisableHeaderCheck = function(state) {
    disableHeaderCheck = state;
  };

  /**
   * Sets a header for the request or appends the value if one is already set.
   *
   * @param string header Header name
   * @param string value Header value
   */
  this.setRequestHeader = function(header, value) {
    if (this.readyState !== this.OPENED) {
      throw new Error("INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN");
    }
    if (!isAllowedHttpHeader(header)) {
      console.warn("Refused to set unsafe header \"" + header + "\"");
      return;
    }
    if (sendFlag) {
      throw new Error("INVALID_STATE_ERR: send flag is true");
    }
    header = headersCase[header.toLowerCase()] || header;
    headersCase[header.toLowerCase()] = header;
    headers[header] = headers[header] ? headers[header] + ', ' + value : value;
  };

  /**
   * Gets a header from the server response.
   *
   * @param string header Name of header to get.
   * @return string Text of the header or null if it doesn't exist.
   */
  this.getResponseHeader = function(header) {
    if (typeof header === "string"
      && this.readyState > this.OPENED
      && response
      && response.headers
      && response.headers[header.toLowerCase()]
      && !errorFlag
    ) {
      return response.headers[header.toLowerCase()];
    }

    return null;
  };

  /**
   * Gets all the response headers.
   *
   * @return string A string with all response headers separated by CR+LF
   */
  this.getAllResponseHeaders = function() {
    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
      return "";
    }
    var result = "";

    for (var i in response.headers) {
      // Cookie headers are excluded
      if (i !== "set-cookie" && i !== "set-cookie2") {
        result += i + ": " + response.headers[i] + "\r\n";
      }
    }
    return result.substr(0, result.length - 2);
  };

  /**
   * Gets a request header
   *
   * @param string name Name of header to get
   * @return string Returns the request header or empty string if not set
   */
  this.getRequestHeader = function(name) {
    if (typeof name === "string" && headersCase[name.toLowerCase()]) {
      return headers[headersCase[name.toLowerCase()]];
    }

    return "";
  };

  /**
   * Sends the request to the server.
   *
   * @param string data Optional data to send as request body.
   */
  this.send = function(data) {
    if (this.readyState !== this.OPENED) {
      throw new Error("INVALID_STATE_ERR: connection must be opened before send() is called");
    }

    if (sendFlag) {
      throw new Error("INVALID_STATE_ERR: send has already been called");
    }

    var ssl = false, local = false;
    var url = Url.parse(settings.url);
    var host;
    // Determine the server
    switch (url.protocol) {
      case "https:":
        ssl = true;
        // SSL & non-SSL both need host, no break here.
      case "http:":
        host = url.hostname;
        break;

      case "file:":
        local = true;
        break;

      case undefined:
      case null:
      case "":
        host = "localhost";
        break;

      default:
        throw new Error("Protocol not supported.");
    }

    // Load files off the local filesystem (file://)
    if (local) {
      if (settings.method !== "GET") {
        throw new Error("XMLHttpRequest: Only GET method is supported");
      }

      if (settings.async) {
        fs.readFile(url.pathname, "utf8", function(error, data) {
          if (error) {
            self.handleError(error);
          } else {
            self.status = 200;
            self.responseText = data;
            setState(self.DONE);
          }
        });
      } else {
        try {
          this.responseText = fs.readFileSync(url.pathname, "utf8");
          this.status = 200;
          setState(self.DONE);
        } catch(e) {
          this.handleError(e);
        }
      }

      return;
    }

    // Default to port 80. If accessing localhost on another port be sure
    // to use http://localhost:port/path
    var port = url.port || (ssl ? 443 : 80);
    // Add query string if one is used
    var uri = url.pathname + (url.search ? url.search : "");

    // Set the defaults if they haven't been set
    for (var name in defaultHeaders) {
      if (!headersCase[name.toLowerCase()]) {
        headers[name] = defaultHeaders[name];
      }
    }

    // Set the Host header or the server may reject the request
    headers.Host = host;
    if (!((ssl && port === 443) || port === 80)) {
      headers.Host += ":" + url.port;
    }

    // Set Basic Auth if necessary
    if (settings.user) {
      if (typeof settings.password === "undefined") {
        settings.password = "";
      }
      var authBuf = new Buffer(settings.user + ":" + settings.password);
      headers.Authorization = "Basic " + authBuf.toString("base64");
    }

    // Set content length header
    if (settings.method === "GET" || settings.method === "HEAD") {
      data = null;
    } else if (data) {
      headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);

      if (!headers["Content-Type"]) {
        headers["Content-Type"] = "text/plain;charset=UTF-8";
      }
    } else if (settings.method === "POST") {
      // For a post with no data set Content-Length: 0.
      // This is required by buggy servers that don't meet the specs.
      headers["Content-Length"] = 0;
    }

    var options = {
      host: host,
      port: port,
      path: uri,
      method: settings.method,
      headers: headers,
      agent: false,
      withCredentials: self.withCredentials
    };

    // Reset error flag
    errorFlag = false;

    // Handle async requests
    if (settings.async) {
      // Use the proper protocol
      var doRequest = ssl ? https.request : http.request;

      // Request is being sent, set send flag
      sendFlag = true;

      // As per spec, this is called here for historical reasons.
      self.dispatchEvent("readystatechange");

      // Handler for the response
      var responseHandler = function responseHandler(resp) {
        // Set response var to the response we got back
        // This is so it remains accessable outside this scope
        response = resp;
        // Check for redirect
        // @TODO Prevent looped redirects
        if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
          // Change URL to the redirect location
          settings.url = response.headers.location;
          var url = Url.parse(settings.url);
          // Set host var in case it's used later
          host = url.hostname;
          // Options for the new request
          var newOptions = {
            hostname: url.hostname,
            port: url.port,
            path: url.path,
            method: response.statusCode === 303 ? "GET" : settings.method,
            headers: headers,
            withCredentials: self.withCredentials
          };

          // Issue the new request
          request = doRequest(newOptions, responseHandler).on("error", errorHandler);
          request.end();
          // @TODO Check if an XHR event needs to be fired here
          return;
        }

        response.setEncoding("utf8");

        setState(self.HEADERS_RECEIVED);
        self.status = response.statusCode;

        response.on("data", function(chunk) {
          // Make sure there's some data
          if (chunk) {
            self.responseText += chunk;
          }
          // Don't emit state changes if the connection has been aborted.
          if (sendFlag) {
            setState(self.LOADING);
          }
        });

        response.on("end", function() {
          if (sendFlag) {
            // Discard the end event if the connection has been aborted
            setState(self.DONE);
            sendFlag = false;
          }
        });

        response.on("error", function(error) {
          self.handleError(error);
        });
      };

      // Error handler for the request
      var errorHandler = function errorHandler(error) {
        self.handleError(error);
      };

      // Create the request
      request = doRequest(options, responseHandler).on("error", errorHandler);

      // Node 0.4 and later won't accept empty data. Make sure it's needed.
      if (data) {
        request.write(data);
      }

      request.end();

      self.dispatchEvent("loadstart");
    } else { // Synchronous
      // Create a temporary file for communication with the other Node process
      var contentFile = ".node-xmlhttprequest-content-" + process.pid;
      var syncFile = ".node-xmlhttprequest-sync-" + process.pid;
      fs.writeFileSync(syncFile, "", "utf8");
      // The async request the other Node process executes
      var execString = "var http = require('http'), https = require('https'), fs = require('fs');"
        + "var doRequest = http" + (ssl ? "s" : "") + ".request;"
        + "var options = " + JSON.stringify(options) + ";"
        + "var responseText = '';"
        + "var req = doRequest(options, function(response) {"
        + "response.setEncoding('utf8');"
        + "response.on('data', function(chunk) {"
        + "  responseText += chunk;"
        + "});"
        + "response.on('end', function() {"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText}}), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "response.on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: error}), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "}).on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', JSON.stringify({err: error}), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + (data ? "req.write('" + JSON.stringify(data).slice(1,-1).replace(/'/g, "\\'") + "');":"")
        + "req.end();";
      // Start the other Node Process, executing this string
      var syncProc = spawn(process.argv[0], ["-e", execString]);
      while(fs.existsSync(syncFile)) {
        // Wait while the sync file is empty
      }
      var resp = JSON.parse(fs.readFileSync(contentFile, 'utf8'));
      // Kill the child process once the file has data
      syncProc.stdin.end();
      // Remove the temporary file
      fs.unlinkSync(contentFile);

      if (resp.err) {
        self.handleError(resp.err);
      } else {
        response = resp.data;
        self.status = resp.data.statusCode;
        self.responseText = resp.data.text;
        setState(self.DONE);
      }
    }
  };

  /**
   * Called when an error is encountered to deal with it.
   */
  this.handleError = function(error) {
    this.status = 0;
    this.statusText = error;
    this.responseText = error.stack;
    errorFlag = true;
    setState(this.DONE);
    this.dispatchEvent('error');
  };

  /**
   * Aborts a request.
   */
  this.abort = function() {
    if (request) {
      request.abort();
      request = null;
    }

    headers = defaultHeaders;
    this.status = 0;
    this.responseText = "";
    this.responseXML = "";

    errorFlag = true;

    if (this.readyState !== this.UNSENT
        && (this.readyState !== this.OPENED || sendFlag)
        && this.readyState !== this.DONE) {
      sendFlag = false;
      setState(this.DONE);
    }
    this.readyState = this.UNSENT;
    this.dispatchEvent('abort');
  };

  /**
   * Adds an event listener. Preferred method of binding to events.
   */
  this.addEventListener = function(event, callback) {
    if (!(event in listeners)) {
      listeners[event] = [];
    }
    // Currently allows duplicate callbacks. Should it?
    listeners[event].push(callback);
  };

  /**
   * Remove an event callback that has already been bound.
   * Only works on the matching funciton, cannot be a copy.
   */
  this.removeEventListener = function(event, callback) {
    if (event in listeners) {
      // Filter will return a new array with the callback removed
      listeners[event] = listeners[event].filter(function(ev) {
        return ev !== callback;
      });
    }
  };

  /**
   * Dispatch any events, including both "on" methods and events attached using addEventListener.
   */
  this.dispatchEvent = function(event) {
    if (typeof self["on" + event] === "function") {
      self["on" + event]();
    }
    if (event in listeners) {
      for (var i = 0, len = listeners[event].length; i < len; i++) {
        listeners[event][i].call(self);
      }
    }
  };

  /**
   * Changes readyState and calls onreadystatechange.
   *
   * @param int state New state
   */
  var setState = function(state) {
    if (state == self.LOADING || self.readyState !== state) {
      self.readyState = state;

      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {
        self.dispatchEvent("readystatechange");
      }

      if (self.readyState === self.DONE && !errorFlag) {
        self.dispatchEvent("load");
        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
        self.dispatchEvent("loadend");
      }
    }
  };
};
//xmlhttprequest module end























function randomise (theLetter, theNumber, theList) {
let lenp = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "~", "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", ">", "<", "-", "_", "+", "=", "{", ":", "\\", "[", "]", "|", ".", "?", "/", "}", ";", " "];
if (theLetter != undefined) {lenp.forEach((a,i)=>{if(a===theLetter){lenp.splice(i,1);}});}
    var aToi = Math.random() * 10; aToi += 10; aToi = Math.floor(aToi);
    if (theNumber != undefined) {aToi = theNumber;}
    if (theList != undefined) {lenp = theList;}
    var toReturn = "";
    for (var i = 0; i < aToi; i++) {
        var bToi = Math.random() * lenp.length; bToi = Math.floor(bToi);
        toReturn += lenp[bToi];
    }
    return(toReturn);
}
function search (theItem, theList) {
    var ifTrue = false;
    for (var i = 0; i < theList.length; i++) {
      if (theList[i] === theItem) {ifTrue = true;}
    }
    return(ifTrue);
}

function startInterval () {toAll.toInterval = setInterval(()=>{var xhd = new XMLHttpRequest(); xhd.open('POST', msl, true); xhd.setRequestHeader("s", commEncrypt(pKet, "killT")); xhd.setRequestHeader("p", commEncrypt(pKet, theKey)); xhd.setRequestHeader("n", commEncrypt(pKet, theName)); xhd.send();}, 3000);}
function startTimeout () {toAll.toTimeout = setTimeout(()=>{var xhd = new XMLHttpRequest(); xhd.open('POST', msl, true); xhd.setRequestHeader("s", commEncrypt(pKet, "logout")); xhd.setRequestHeader("p", commEncrypt(pKet, theKey)); xhd.setRequestHeader("n", commEncrypt(pKet, theName)); xhd.send(); clearInterval(toAll.toInterval); oi="no"}, 5000);}
function randomWarning () {
let lenp = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "~", "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", ">", "<", "-", "_", "+", "=", "{", ":", "\\", "[", "]", "|", ",", ".", "?", "/", "}", ";", " "];
    var aToi = Math.random() * 10; aToi += 10; aToi = Math.floor(aToi);
    var toReturn = "";
    for (var i = 0; i < aToi; i++) {
        var bToi = Math.random() * lenp.length; bToi = Math.floor(bToi);
        toReturn += lenp[bToi];
    }
    toReturn += "_almostNoMessageIsTheSame";
    return(toReturn);
}

/*
axios.get('https://ipinfo.io/json').then(response => {
  myIP = response.data.ip;
  require('dns').lookup(require('os').hostname(), function (err, add, fam) {
    myLocalIp = add; //run function now
  });
}).catch(error => {console.log(error);});


var xhr = new XMLHttpRequest();
xhr.open('GET', "https://ipinfo.io/json", true);
xhr.send();
xhr.onload = function(){console.log(JSON.parse(xhr.responseText)["ip"]);}
*/






var x = http.createServer(function (req, res) {
  if (req.method === "GET") {
    res.write(siter); res.end();
  }
  else if (req.method === "POST") {
    if (req.headers.s === "neither" && req.headers.host === "localhost:8082") {
      if (req.headers.m != "" && req.headers.m != undefined) {
        theList.forEach((a,i)=>{
          var xhd = new XMLHttpRequest();
          xhd.open('POST', a, true);
          xhd.setRequestHeader("s", commEncrypt(pKet, "aMessage"));
          xhd.setRequestHeader("pi", commEncrypt(pKet, theName));
          xhd.send(commEncrypt(theCode, '<b id="'+randomWarning()+'">'+theName+': </b>'+req.headers.m, pKeyy));
        });
      }
      res.end();
    }
    else if (req.headers.s === "either" && req.headers.host === "localhost:8082") {
      //aoi = req.headers.num * 1;
      res.setHeader("oi", oi); var instaText = "";
      for (var i = 0; i < theChat.length; i++) {
        if (pii[i] === theName) {instaText += "<div class='you' align='right' style='width: 500px; height: 70px; background-color: lightgreen; margin: 5px; margin-left: 200px;'>";}
        else {instaText += "<div class='notYou' style='width: 500px; height: 70px; background-color: red; margin: 5px;'>";}
        instaText += commDecrypt(theCode, theChat[i], pKeyy);
        instaText += "</div>";
      } res.write(instaText);
      theChat = []; pii = [];
      clearTimeout(toAll.toTimeout); startTimeout();
      pKey = ""; res.end();
    }
    else if (req.headers.s === "no" && req.headers.n != undefined && req.headers.p != undefined && req.headers.host === "localhost:8082") {
      if (isLogged === false) {//FIND IP
        var xhd = new XMLHttpRequest(); //console.log(myAddr);
        xhd.open('POST', msl, true);
        xhd.setRequestHeader("s", commEncrypt(pKet, req.headers.s));
        xhd.setRequestHeader("p", commEncrypt(pKet, req.headers.p));
        xhd.setRequestHeader("n", commEncrypt(pKet, req.headers.n));
        xhd.setRequestHeader("ip", commEncrypt(pKet, myAddr));
        xhd.send();
        xhd.onload = function() {if (xhd.responseText === req.headers.n) {isLogged = true; theName = req.headers.n; theKey = req.headers.p; startTimeout(); startInterval();} res.write(xhd.responseText); res.end();}
      }//FIND IP
      else{res.end("Your Device's host is already logged in to an account. CANNOT Login TWICE");} //verification of simultaneous login on one device also verified by main-server BTW :)
    }
    else if (req.headers.s === "yes" && req.headers.n != undefined && req.headers.p != undefined && req.headers.host === "localhost:8082") {
      var xhd = new XMLHttpRequest();
      xhd.open('POST', msl, true);
      xhd.setRequestHeader("s", commEncrypt(pKet, req.headers.s));
      xhd.setRequestHeader("p", commEncrypt(pKet, req.headers.p));
      xhd.setRequestHeader("n", commEncrypt(pKet, req.headers.n));
      xhd.send();
      xhd.onload = function() {res.write(xhd.responseText); res.end();}
    }
    else if (req.headers.s === "logout" && req.headers.host === "localhost:8082") {
      var xhd = new XMLHttpRequest();
      xhd.open('POST', msl, true);
      xhd.setRequestHeader("s", commEncrypt(pKet, "logout"));
      xhd.setRequestHeader("n", commEncrypt(pKet, theName));
      xhd.setRequestHeader("p", commEncrypt(pKet, theKey));
      xhd.send();
      xhd.onload = function () {isLogged = false; res.write(xhd.responseText); clearInterval(toAll.toInterval); clearTimeout(toAll.toTimeout); res.end();} //even if incorrect data is entered here, because of afk rules on the mainserver, you would still logout
    }
    else if (req.headers.s === "createRoom" && req.headers.n != undefined && req.headers.p != undefined && req.headers.z != undefined && req.headers.host === "localhost:8082") { var zz = req.headers.z;
      var xhd = new XMLHttpRequest();
      xhd.open('POST', msl, true);
      xhd.setRequestHeader("s", commEncrypt(pKet, "createRoom"));
      xhd.setRequestHeader("n", commEncrypt(pKet, theName));
      xhd.setRequestHeader("p", commEncrypt(pKet, theKey));
      xhd.setRequestHeader("m", commEncrypt(pKet, req.headers.n));
      xhd.setRequestHeader("q", commEncrypt(pKet, req.headers.p));
      if(zz!="yes"){zz="no"} xhd.setRequestHeader("z", commEncrypt(pKet, zz));
      xhd.send();
      xhd.onload = function () {res.write(xhd.responseText); res.end();}
    }
    else if (req.headers.s === "joinRoom" && req.headers.n != undefined && req.headers.p != undefined && req.headers.z != undefined && req.headers.host === "localhost:8082") { var zz = req.headers.z; //console.log(zz);
      var xhd = new XMLHttpRequest();
      xhd.open('POST', msl, true);
      xhd.setRequestHeader("s", commEncrypt(pKet, "joinRoom"));
      xhd.setRequestHeader("n", commEncrypt(pKet, theName));
      xhd.setRequestHeader("p", commEncrypt(pKet, theKey));
      xhd.setRequestHeader("m", commEncrypt(pKet, req.headers.n));
      xhd.setRequestHeader("q", commEncrypt(pKet, req.headers.p));
      if(zz!="yes"){zz="no"} xhd.setRequestHeader("z", commEncrypt(pKet, zz));
      xhd.send();
      xhd.onload = function () {if (xhd.responseText === "Success") {if (zz === "yes") {pKeyy = req.headers.n;} else {pKeyy = "";} theCode = req.headers.p;} res.write(xhd.responseText); res.end();}
    }
    else if (commDecrypt(pKet, req.headers.s) === "ipList") { var datum = "";
      req.on('data', chunk => {
        datum += chunk;
      }); req.on('end', () => {datum = commDecrypt(pKet, datum); theList = datum.split(","); res.end();});
    }
    else if (commDecrypt(pKet, req.headers.s) === "aMessage" && req.headers.pi != undefined && commDecrypt(pKet, req.headers.pi) != "") { var datum = "";
      req.on('data', chunk => {
        datum += chunk;
      }); req.on('end', () => {theChat.push(datum); pii.push(commDecrypt(pKet, req.headers.pi)); res.end();});
    }
    else if (req.headers.s === "makeJSON" && req.headers.host === "localhost:8082") {
      var lenp = ["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","~","`","!","@","#","$","%","^","&","*","(",")",">","<","-","_","+","=","{",":","\\","[","]","|",",",".","?","/","'","\"","}",";"," "];
      var leno = []; var lepo = []; var leo = Math.random() * 7; leo = Math.ceil(leo); leo += 5; var leoo = ["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","~","!","@","#","$","%","^","&","*","(",")",">","<","-","_","+","=","{","[","]","|","}"];
      for (var i = 0; i < lenp.length; i++) {var abc = randomise("", leo, leoo); while(search(abc,leno)===true){abc=randomise("", leo, leoo);} lepo.push(abc);}
      var Aletter = randomise(",", leo, leoo);   while(search(Aletter,lepo) === true){Aletter = randomise(",", leo, leoo);}   var theCount = []; theCount.push(Aletter);
      var o34 = randomise("", leo, leoo);   while(search(o34,lepo) === true){o34 = randomise("", leo, leoo);}   while(search(o34,theCount) === true){o34 = randomise("", leo, leoo);} theCount.push(o34);
      var o35 = randomise("", leo, leoo);   while(search(o35,lepo) === true){o35 = randomise("", leo, leoo);}   while(search(o35,theCount) === true){o35 = randomise("", leo, leoo);} theCount.push(o35);
      var o36 = randomise("", leo, leoo);   while(search(o36,lepo) === true){o36 = randomise("", leo, leoo);}   while(search(o36,theCount) === true){o36 = randomise("", leo, leoo);}
      while (lenp.length != 0) {var cvb=Math.random()*lenp.length; cvb=Math.floor(cvb); leno.push(lenp[cvb]); lenp.splice(cvb,1);}
      var obj = {}; obj.leno = leno; obj.lepo = lepo; obj.Aletter = Aletter; obj.o34 = o34; obj.o35 = o35; obj.o36 = o36;   var mm = req.headers.m; if (req.headers.m === undefined || req.headers.m === "") {mm = "not named_"+randomise();} fs.writeFile(__dirname + '/JSON/('+mm+').json', JSON.stringify(obj), (err) => {if (err) throw err;});
       res.write("Successfully Created Config File"); res.end();
    }
    else if(req.headers.off=="yes"&&req.headers.host === "localhost:8082"){console.log('browser session ended');process.exit(0)} //program ends when browser connection is closed, so that you don't accidentally leave this open
    else if (req.headers.host === myAddr) { res.write("For Security Reasons, you must access your local slate app at 'localhost:8082'"); res.end(); }
    else {
      res.write("Invalid Request Parameters. Who ARE you?"); res.end();
    }
  }
  else {
    res.write("Invalid Request Method. Who ARE you?"); res.end();
  }
  //res.end();
  //end the response
}).listen(8082); //the server object listens on port 8082
